<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">



<!-- Baidu Analytics -->
<script>
  var _hmt = _hmt || [];
  (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?4dbc75a8d627e17a8714e4c8b2e9afa8";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();
</script>
<!-- End Baidu Analytics -->


<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

  <meta name="author" content="shixiongfei">


  <meta name="subtitle" content="LESS is MORE">


  <meta name="description" content="Mind is Power and Less is More!">


  <meta name="keywords" content="javascript, typescript, node, nodejs, c, ml, sql, git, linux, macos, windows, game, app, 教程, 软件, 编程, 开发, 运维, 云计算, 网络, 互联网, 数据分析, 量化, 交易">


<title>Erlang极简学习笔记&lt;10&gt;——OTP篇 | Xiongfei Shi</title>



<link rel="icon" href="/favicon.ico">



<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/nprogress/nprogress.css">


<link rel="stylesheet" href="/lib/fancybox/fancybox.min.css">


<link rel="stylesheet" href="/lib/tocbot/tocbot.min.css">



<script src="/lib/jquery.min.js"></script>


<script src="/lib/iconify-icon.min.js"></script>


<script src="https://cdn.tailwindcss.com?plugins=typography,line-clamp"></script>
<script>
  tailwind.config = {
    darkMode: 'class',
  }
</script>


<script src="/lib/nprogress/nprogress.js"></script>

<script>
  $(document).ready(() => {
    NProgress.configure({
      showSpinner: false,
    });
    NProgress.start();
    $("#nprogress .bar").css({
      background: "#de7441",
    });
    $("#nprogress .peg").css({
      "box-shadow": "0 0 2px #de7441, 0 0 4px #de7441",
    });
    $("#nprogress .spinner-icon").css({
      "border-top-color": "#de7441",
      "border-left-color": "#de7441",
    });
    setTimeout(function () {
      NProgress.done();
      $(".fade").removeClass("out");
    }, 800);
  });
</script>

<script>
  (function () {
    const prefersDark =
      window.matchMedia &&
      window.matchMedia("(prefers-color-scheme: dark)").matches;
    const setting = localStorage.getItem("hexo-color-scheme") || "auto";
    if (setting === "dark" || (prefersDark && setting !== "light"))
      document.documentElement.classList.toggle("dark", true);
  })();
  window.onload = function () {
    // init iconify icon
    const isDark = document.documentElement.classList.contains("dark");
    if (isDark) {
      $("#toggle-dark").attr("icon", "ri:moon-line");
    } else {
      $("#toggle-dark").attr("icon", "ri:sun-line");
    }

    const toggleDark = () => {
      console.log("toggle dark");
      const darkMode = document.documentElement.classList.toggle("dark");
      localStorage.setItem("hexo-color-scheme", darkMode ? "dark" : "light");
      $("#toggle-dark").attr("icon", darkMode ? "ri:moon-line" : "ri:sun-line");
    };

    $("#toggle-dark").click(toggleDark);
  };
</script>




<meta name="generator" content="Hexo 6.3.0"></head>
<body class="font-sans bg-white dark:bg-zinc-900 text-gray-700 dark:text-gray-200">
  <header class="fixed w-full px-5 py-1 z-10 backdrop-blur-xl backdrop-saturate-150 border-b border-black/5">
  <div class="max-auto">
    <nav class="flex items-center text-base">
      <a href="/" class="group">
        <h2 class="font-medium tracking-tighterp text-l p-2">
          <img class="w-5 mr-2 inline-block transition-transform group-hover:rotate-[30deg]" src="/images/logo.svg" alt="Xiongfei Shi" />
          Xiongfei Shi
        </h2>
      </a>
      <div id="header-title" class="opacity-0 md:ml-2 md:mt-[0.1rem] text-xs font-medium whitespace-nowrap overflow-hidden overflow-ellipsis">
        Categories
      </div>
      <div class="flex-1"></div>
      <div class="flex items-center gap-3">
        
          <a class="hidden sm:flex" href="/archives">Posts</a>
        
          <a class="hidden sm:flex" href="/categories">Categories</a>
        
          <a class="hidden sm:flex" href="/tags">Tags</a>
        
        
          
            <a class="w-5 h-5 hidden sm:flex" title="Github" target="_blank" rel="noopener" href="https://github.com/shixiongfei">
              <iconify-icon width="20" icon="ri:github-line"></iconify-icon>
            </a>
          
            <a class="w-5 h-5 hidden sm:flex" title="ZhiHu" target="_blank" rel="noopener" href="https://www.zhihu.com/people/shixiongfei">
              <iconify-icon width="20" icon="ri:zhihu-line"></iconify-icon>
            </a>
          
        
        <a class="w-5 h-5" title="toggle theme">
          <iconify-icon width="20" icon="ri:sun-line" id="toggle-dark"></iconify-icon>
        </a>
      </div>
      <div class="flex items-center justify-center gap-3 ml-3 sm:hidden">
        <span class="w-5 h-5" aria-hidden="true" role="img" id="open-menu">
          <iconify-icon width="20" icon="carbon:menu" ></iconify-icon>
        </span>
        <span class="w-5 h-5 hidden" aria-hidden="true" role="img" id="close-menu">
          <iconify-icon  width="20" icon="carbon:close" ></iconify-icon>
        </span>
      </div>
    </nav>
  </div>
</header>
<div id="menu-panel" class="h-0 overflow-hidden sm:hidden fixed left-0 right-0 top-12 bottom-0 z-10">
  <div id="menu-content" class="relative z-20 bg-white/80 px-6 sm:px-8 py-2 backdrop-blur-xl -translate-y-full transition-transform duration-300">
    <ul class="nav flex flex-col sm:flex-row text-sm font-medium">
      
        <li class="nav-portfolio sm:mx-2 border-b sm:border-0 border-black/5 last:border-0 hover:text-main">
          <a href="/archives" class="flex h-12 sm:h-auto items-center">Posts</a>
        </li>
      
        <li class="nav-portfolio sm:mx-2 border-b sm:border-0 border-black/5 last:border-0 hover:text-main">
          <a href="/categories" class="flex h-12 sm:h-auto items-center">Categories</a>
        </li>
      
        <li class="nav-portfolio sm:mx-2 border-b sm:border-0 border-black/5 last:border-0 hover:text-main">
          <a href="/tags" class="flex h-12 sm:h-auto items-center">Tags</a>
        </li>
      
    </ul>
  </div>
  <div class="mask bg-black/20 absolute inset-0"></div>
</div>

  <main class="p-12">
    <!-- toc -->

<section class="px-6 max-w-prose mx-auto md:px-0">
  <!-- header -->
  <header class="overflow-hidden pt-6 pb-6 md:pt-12">
    <div class="pt-4 md:pt-6">
      <h1 id="article-title" class="text-[2rem] font-bold leading-snug mb-4 md:mb-6 md:text-[2.6rem]">
        Erlang极简学习笔记<10>——OTP篇
      </h1>
      <p class="mb-6">
        
      </p>
      <div>
        <section class="flex items-center gap-3 text-sm">
          <time>2019-08-14 00:19:00</time>
          <span class="text-gray-400">·</span>
          <span>19 min</span>
          <span class="text-gray-400">·</span>
          <span>5.3k words</span>
        </section>
      </div>
    </div>
  </header>
  <!-- content -->
  <article class="post-content mt-10 prose prose-code:before:content-none prose-code:after:content-none prose-code:border prose-code:border-gray-700 prose-code:rounded prose-code:px-1 prose-code:py-0.5 dark:prose-invert post-content">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><ul>
<li><p>Erlang的巨大优势一部分来自于其并发和分布式特性，还有一部分来自其错误处理能力，OTP框架则是第三部分</p>
</li>
<li><p>在一个服务器框架中，我们通常需要解决的问题有：进程（服务）命名、超时配置、调试信息、非期望消息处理、代码热加载、特殊错误的处理、公共回复代码、服务器关闭的处理、保证服务器和监督者的配合等。自己动手解决这些问题是一件有风险的事情，很幸运，Erlang&#x2F;OTP已经在 <code>gen_server</code> 行为中解决了所有这些问题</p>
</li>
<li><p>OTP的 <code>gen_server</code> 行为会要求提供一些进程的初始化和结束、基于消息发送的同步和异步处理以及其他任务的处理函数</p>
</li>
<li><p><code>init/1</code> 函数负责初始化服务器的状态，并完成服务器需要的所有一次性任务。这个函数可以返回 <code>&#123;ok, State&#125;</code> 、 <code>&#123;ok, State, TimeOut&#125;</code> 、 <code>&#123;ok, State, hibernate&#125;</code> 、 <code>&#123;stop, Reason&#125;</code> 以及 <code>ignore</code></p>
</li>
<li><p>常规的 <code>&#123;ok, State&#125;</code> 返回值无需解释，只要记住 <code>State</code> 会直接传给进程的主循环，并作为进程的状态一直保存在那里就行了。</p>
</li>
<li><p>当期望服务器在某个时间期限之前能收到一条消息时，可以使用 <code>TimeOut</code> 变量。如果到期没有收到任何消息，那么会给服务器发送一条特殊的消息（原子 <code>timeout</code> ），可以在 <code>handle_info/2</code> 中处理这条消息。很少会在产品代码使用这个选项，因为不能总是知道会收到哪条消息，而任意一条消息都会重置计时器。通常，更好的方法是使用 <code>erlang:start_timer/3</code> 之类的函数，可以获得更好的处理控制</p>
</li>
<li><p>如果确实觉得进程在很长一段时间内不会有什么消息要处理，并且担心内存问题，那么可以在元组中使用 <code>hibernate</code> 原子。一般来讲， <code>hibernate</code> 选项会缩减进程的状态，直到它收到一条消息，不过会多耗费些处理能力。如果在是否使用 <code>hibernate</code> 选项时存有疑惑，就说明不太需要它</p>
</li>
<li><p>如果在初始化的过程中出现了错误，可以返回 <code>&#123;stop, Reason&#125;</code></p>
</li>
<li><p>注意！当执行 <code>init/1</code> 函数时，创建服务器的进程会被阻塞。这是因为它在等待一条“就绪”消息，这条消息由 <code>gen_server</code> 模块自动发送以确认一切正常</p>
</li>
<li><p><code>handle_call/2</code> 函数用于处理同步消息。它有3个参数： <code>Request</code> 、 <code>From</code> 以及 <code>State</code></p>
</li>
<li><p>在 <code>gen_server</code> 中，有8种不同的返回值可供选择，这些返回值都是元组形式</p>
<ul>
<li><code>&#123;reply, Reply, NewState&#125;</code></li>
<li><code>&#123;reply, Reply, NewState, TimeOut&#125;</code></li>
<li><code>&#123;reply, Reply, NewState, hibernate&#125;</code></li>
<li><code>&#123;noreply, NewState&#125;</code></li>
<li><code>&#123;noreply, NewState, TimeOut&#125;</code></li>
<li><code>&#123;noreply, NewState, hibernate&#125;</code></li>
<li><code>&#123;stop, Reason, Reply, NewState&#125;</code></li>
<li><code>&#123;stop, Reason, NewState&#125;</code></li>
</ul>
</li>
<li><p>这些返回值中， <code>TimeOut</code> 和 <code>hibernate</code> 的工作方式和 <code>init/1</code> 中的一样。 <code>Reply</code> 中的内容会被原封不动地发回给调用服务器的进程</p>
</li>
<li><p>共有3种不同的 <code>noreply</code> 选项，当使用 <code>noreply</code> 时，服务器的通用部分会认为你将自己发送回应消息，可以调用 <code>gen_server:reply/2</code> 发送回应</p>
</li>
<li><p>在绝大部分情况下，只需要使用 <code>reply</code> 元组。不过有些情况确实需要使用 <code>noreply</code> ，例如，希望由另一个进程来替你发送回应，或者想先发送一条确认消息（“嗨！我收到消息了！”），然后继续处理（处理完无需回应）。如果这是所需要的场景，那么只能使用 <code>gen_server:reply/2</code> ，否则，调用会超时然后崩溃</p>
</li>
<li><p><code>handle_cast</code> 函数用于异步消息的处理，它的参数是： <code>Message</code> 和 <code>State</code> 。和 <code>handle_call/3</code> 类似，其中也可以进行任何处理。不过它只能返回 <code>noreply</code> 元组</p>
<ul>
<li><code>&#123;noreply, NewState&#125;</code></li>
<li><code>&#123;noreply, NewState, TimeOut&#125;</code></li>
<li><code>&#123;noreply, NewState, hibernate&#125;</code></li>
<li><code>&#123;stop, Reason, NewState&#125;</code></li>
</ul>
</li>
<li><p><code>handle_info</code> 函数用于处理和接口不相容的消息。它和 <code>handle_case/2</code> 非常类似，事实上，返回值也完全一样。它们之间的区别在于，这个回调函数只用来处理直接通过 <code>!</code> 操作符发送的消息，以及如 <code>init/1</code> 中 <code>timeout</code> 、监控器通知或者 <code>EXIT</code> 信号之类的特殊消息</p>
</li>
<li><p>当上面3种 <code>handle_something</code> 函数返回形如 <code>&#123;stop, Reason, NewState&#125;</code> 或者 <code>&#123;stop, Reason, Reply, NewState&#125;</code> 的元组时，会调用 <code>terminate/2</code> 函数。它有两个参数： <code>Reason</code> 和 <code>State</code> ，分别对应 <code>stop</code> 元组中的同名字段</p>
</li>
<li><p>当父进程（创建服务器的进程）死亡时，也会调用 <code>terminate/2</code> 函数，不过这只会发生在 <code>gen_server</code> 捕获了退出信号的时候</p>
</li>
<li><p>如果在调用 <code>terminate/2</code> 时，原因不是 <code>normal</code> 、 <code>shutdown</code> 或者 <code>&#123;shutdown, Term&#125;</code> ，那么OTP框架会把这当成故障，并会把进程的状态、故障原因、最后收到的消息等记入日志。这让调试变得更加容易，可以帮助你快速定位问题</p>
</li>
<li><p>这个函数和 <code>init/1</code> 正好相反，因此所有在 <code>init/1</code> 中做的动作都应该在 <code>terminate/2</code> 中有对应的取消动作</p>
</li>
<li><p><code>code_change</code> 函数用于代码升级，它的调用形式是 <code>code_change(PreviousVersion, State, Extra)</code> 。其中，变量 <code>PreviousVersion</code> 在升级时是版本数据项本身，在降级时是 <code>&#123;down, Version&#125;</code> 。 <code>State</code> 变量中保存着服务器当前的所有状态数据，可以对其进行转换</p>
</li>
<li><p>假如我们一开始使用一个有序字典来存储所有数据。一段时间之后，有序字典变得越来越慢，我们决定用常规字典把它替换掉。为了避免进程在接下来的调用中崩溃，可以在这个函数中安全地进行数据结构的转换。所要做的就是用 <code>&#123;ok, NewState&#125;</code> 返回新的状态</p>
</li>
<li><p><code>gen_server</code> 的调用与回调关系</p>
<ul>
<li><code>gen_server:start/3-4</code>  &lt;-&gt;  <code>YourModule:init/1</code></li>
<li><code>gen_server:start_link/3-4</code>  &lt;-&gt;  <code>YourModule:init/1</code></li>
<li><code>gen_server:call/2-3</code>  &lt;-&gt;  <code>YourModule:handle_call/3</code></li>
<li><code>gen_server:cast/2</code>  &lt;-&gt;  <code>YourModule:handle_cast/2</code></li>
</ul>
</li>
<li><p>还有其他几个回调函数如 <code>handle_info/2</code> 、 <code>terminate/2</code> 和 <code>code_change/3</code> ，这些回调函数主要处理一些特殊情况</p>
</li>
<li><p><code>gen_fsm</code> 行为和 <code>gen_server</code> 有点类似，因为 <code>gen_fsm</code> 是 <code>gen_server</code> 行为的一个专用版本。它们之间最大的区别在于， <code>gen_fsm</code> 中不再处理 <code>call</code> 消息和 <code>cast</code> 消息，而是处理同步和异步事件</p>
</li>
<li><p>FSM中的 <code>init</code> 函数和通用服务器中使用的 <code>init/1</code> 完全一样，除了返回值多一些，可接受的返回值为： <code>&#123;ok, StateName, Data&#125;</code> 、 <code>&#123;ok, StateName, Data, Timeout&#125;</code> 、 <code>&#123;ok, StateName, Data, hibernate&#125;</code> 以及 <code>&#123;stop, Reason&#125;</code> 。 <code>stop</code> 元组的工作原理和 <code>gen_server</code> 中的完全一样， <code>hibernate</code> 和 <code>Timeout</code> 的语义也保持不变</p>
</li>
<li><p><code>StateName</code> 是一个新出现的变量。 <code>StateName</code> 是原子类型，表示下一个被调用的回调函数</p>
</li>
<li><p>函数 <code>StateName/2</code> 和 <code>StateName/3</code> 是占位名字，由你来决定它们的内容</p>
</li>
<li><p>假设 <code>init/1</code> 函数返回元组 <code>&#123;ok, sitting, dog&#125;</code> ，这意味着FSM会处于sitting状态</p>
</li>
<li><p>在上面的FSM中， <code>init/1</code> 函数的返回值表明我们该处于 <code>sitting</code> 状态。当 <code>gen_fsm</code> 进程收到一个事件时，函数 <code>sitting/2</code> 或者 <code>sitting/3</code> 会被调用。对于异步事件，会调用 <code>sitting/2</code> 函数，对于同步事件，会调用 <code>sitting/3</code> 函数</p>
</li>
<li><p>函数 <code>sitting/2</code> (或者一般的说， <code>StateName/2</code> )有两个参数：一个是 <code>Event</code> ，作为事件发送来的实际消息；一个是 <code>StateData</code> ，调用携带的数据</p>
</li>
<li><p><code>sitting/2</code> 函数可以返回以下几种元组</p>
<ul>
<li><code>&#123;next_state, NextStateName, NewStateData&#125;</code></li>
<li><code>&#123;next_state, NextStateName, NewStateData, Timeout&#125;</code></li>
<li><code>&#123;next_state, NextStateName, hibernate&#125;</code></li>
<li><code>&#123;stop, Reason, NewStateData&#125;</code></li>
</ul>
</li>
<li><p>函数 <code>sitting/3</code> 的参数与此类似，只是在 <code>Event</code> 和 <code>StateData</code> 之间多了一个 <code>From</code> 参数。 <code>From</code> 参数和 <code>gen_fsm:reply/2</code> 的用法与 <code>gen_server</code> 中的完全一样</p>
</li>
<li><p>函数 <code>StateName/3</code> 可以返回如下元组</p>
<ul>
<li><code>&#123;reply, Reply, NextStateName, NewStateData&#125;</code></li>
<li><code>&#123;reply, Reply, NextStateName, NewStateData, Timeout&#125;</code></li>
<li><code>&#123;reply, Reply, NextStateName, NewStateData, hibernate&#125;</code></li>
<li><code>&#123;next_state, NextStateName, NewStateData&#125;</code></li>
<li><code>&#123;next_state, NextStateName, NewStateData, Timeout&#125;</code></li>
<li><code>&#123;next_state, NextStateName, NewStateData, hibernate&#125;</code></li>
<li><code>&#123;stop, Reason, Reply, NewStateData&#125;</code></li>
<li><code>&#123;stop, Reason, NewStateData&#125;</code></li>
</ul>
</li>
<li><p>注意，这些函数数量不受限制，只要被导出就行。元组中的原子 <code>NextStateName</code> 决定了下一次会调用哪个函数</p>
</li>
<li><p>无论当前在哪个状态中，全局事件都会触发一个特定反应。由于这类事件在每个状态中都会以同样的方式处理，因此 <code>handle_event/3</code> 回调函数正好满足需要。这个函数的参数和 <code>StateName/2</code> 类似，不过它在中间多了一个参数 <code>StateName(handle_event(Event, StateName, Data))</code> ，这个参数表明了收到事件时所处的状态。它的返回值和函数 <code>StateName/2</code> 一样</p>
</li>
<li><p>回调函数 <code>handle_sync_event/4</code> 和 <code>StateName/3</code> 的关系与 <code>handle_event/2</code> 和 <code>StateName/2</code> 的关系一样。这个函数处理同步全局事件，参数和所返回的元组种类都和 <code>StateName/3</code> 一样</p>
</li>
<li><p>通过向FSM发送事件所使用的函数，我们可以知道一个事件是全局的还是针对某个特定状态的。被 <code>StateName/2</code> 函数处理的异步事件是用函数 <code>gen_fsm:send_event/2</code> 发送的，而被 <code>StateName/3</code> 函数处理的同步事件是用函数 <code>gen_fsm:sync_send_event/2-3</code> 发送的（第三个可选的参数是超时）</p>
</li>
<li><p>两个对等的用来发送全局事件的函数为： <code>gen_fsm:send_all_state_event/2</code> 和 <code>gen_fsm:sync_send_all_state_event/2-3</code></p>
</li>
<li><p>FSM中 <code>code_change</code> 函数的工作方式和 <code>gen_server</code> 中的完全一样，只是多处一个额外的状态参数，如： <code>code_change(OldVersion, StateName, Data, Extra)</code> ，并且返回的元组格式为 <code>&#123; ok, NextStateName, NewStateData &#125;</code></p>
</li>
<li><p>同样的，FSM中 <code>terminate</code> 的行为和通用服务器中也类似， <code>terminate(Reason, StateName, Data)</code> 函数做多额工作应该和 <code>init/1</code> 相反</p>
</li>
<li><p><code>gen_event</code> 行为与 <code>gen_server</code> 以及 <code>gen_fsm</code> 有很大的不同，它根本不需要实际启动一个进程。之所以不需要进程是因为它的工作方式是“接受一组回调函数”</p>
</li>
<li><p>简单来讲， <code>gen_event</code> 行为运行这个接受并调用回调函数的事件管理器进程，而你只需要提供包含这些回调函数的模块即可。这意味着你无需关心事件分派，只需按照事件管理器要求的格式放置回调函数即可。所有的事件管理就自然都有了，你只需提供应用特定的东西</p>
</li>
<li><p><code>init</code> 和 <code>terminate</code> 函数与我们前面看到的 <code>gen_server</code> 和 <code>gen_fsm</code> 行为中的类似。 <code>init/1</code> 函数接收列表参数，返回 <code>&#123;ok, State&#125;</code> 。在 <code>init/1</code> 中创建的东西，要在 <code>terminate/2</code> 函数中有对应释放操作</p>
</li>
<li><p><code>handle_event(Event, State)</code> 函数可以说是 <code>gen_event</code> 回调模块的核心函数。和 <code>gen_server</code> 中的 <code>handle_cast/2</code> 一样， <code>handle_event/2</code> 函数也是异步的。不过，它的返回值有所不同：</p>
<ul>
<li><code>&#123;ok, NewState&#125;</code></li>
<li><code>&#123;ok, NewState, hibernate&#125;</code> ，让事件管理器进程进入休眠状态，直到收到下一个事件</li>
<li><code>remove_handler</code></li>
<li><code>&#123;swap_handler, Args1, NewState, NewHandler, Args2&#125;</code></li>
</ul>
</li>
<li><p>返回值 <code>&#123;ok, NewState&#125;</code> 元组的含义和 <code>gen_server:handle_cast/2</code> 函数中的一样。它只更新自己的状态，不做任何回应。</p>
</li>
<li><p>返回 <code>&#123;ok, NewState, hibernate&#125;</code> 则会使整个事件管理器进入休眠状态。记住，事件处理器和其他管理器运行在同一个进程中</p>
</li>
<li><p>返回 <code>remove_handler</code> 则会导致事件处理器从事件管理器中删除。当某个事件处理器知道自己已经完成工作并且无其他任务时，可以使用这个返回值</p>
</li>
<li><p>最后一个返回值 <code>&#123;swap_handler, Args1, NewState, NewHandler, Args2&#125;</code> ，它移除当前事件处理器并用一个新的替代它。事件管理器首先调用 <code>CurrentHandler:terminate(Args1, NewState)</code> 函数，并移除当前的事件处理器。接着调用 <code>NewHandler:init(Args2, ResultFromTerminate)</code> 函数，添加新的事件处理器。</p>
</li>
<li><p>所有事件都是通过 <code>gen_event:notify/2</code> 函数触发的，和 <code>gen_server:cast/2</code> 一样，它也是异步的。还有另外一个函数 <code>gen_event:sync_notify/2</code> ，它是同步的。由于 <code>handle_event/2</code> 是异步的，这里的同步指的是，当所有事件处理器都收到这个事件并且处理完毕后， <code>sync_notify</code> 函数才会返回。在那之前，事件管理器会一直阻塞调用进程，不予响应</p>
</li>
<li><p><code>handle_call</code> 函数和 <code>gen_server</code> 的 <code>handle_call</code> 回调函数类似，不同之处在于，它可以返回 <code>&#123;ok, Reply, NewState&#125;</code> 、 <code>&#123;ok, Reply, NewState, hibernate&#125;</code> 、 <code>&#123;remove_handler, Reply&#125;</code> 以及 <code>&#123;swap_handler, Reply, Args1, NewState, Handler2, Args2&#125;</code> 。使用 <code>gen_event:call/3-4</code> 函数就可以发起该调用</p>
</li>
<li><p><code>handle_info</code> 回调和 <code>handle_event</code> 回调非常相似（有着同样的返回值和含义），唯一的不同在于， <code>handle_info</code> 只处理带外消息，如退出信号或使用 <code>!</code> 操作符直接向事件管理器进程发送消息。它的使用场景和 <code>gen_server</code> 以及 <code>gen_fsm</code> 中的 <code>handle_info</code> 的使用场景类似</p>
</li>
<li><p><code>code_change</code> 函数的工作方式和 <code>gen_server</code> 中的一样，不过它仅仅针对单独的事件处理器。它的参数为： <code>OldVsn</code> 、 <code>State</code> 、 <code>Extra</code> ，分别表示版本号、当前事件处理器的状态、最后这个参数—— <code>Extra</code> ，目前可以不用关心。这个方法只要返回 <code>&#123;ok, NewState&#125;</code> 即可</p>
</li>
<li><p>在所有OTP中，监督者是最容易使用和理解的一个，但也是最难设计好的一个。在Erlang中应该把所有东西都监督起来，此外，监督机制还可以让你以恰当的顺序终止应用</p>
</li>
<li><p>当想终止一个应用时，只需去终止虚拟机中最顶层的那个监督者（调用 <code>init:stop/1</code> 函数就可以了）。然后这个监督者会接着要求它的子进程停止运行。如果某个子进程也是一个监督者，它会做同样的事情</p>
</li>
<li><p>如果没有用树形结构来组织所有的进程，那么很难让VM以井然有序的方式终止。当然，有时也会出现进程因某种原因被卡住而不能正常终止的情况。此时，监督者可以强行杀死这个进程。</p>
</li>
<li><p>监督者使用起来很简单，我们只需要提供一个回调函数： <code>init/1</code> 。麻烦的地方在于这个函数的返回值非常复杂。下面是一个返回值的例子：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;ok, &#123;&#123;one_for_all, <span class="number">5</span>, <span class="number">60</span>&#125;,</span><br><span class="line">      [&#123;fake_id,</span><br><span class="line">        &#123;fake_mod, start_link, [SomeArg]&#125;,</span><br><span class="line">        permanent,</span><br><span class="line">        <span class="number">5000</span>,</span><br><span class="line">        worker,</span><br><span class="line">        [fake_mode]&#125;,</span><br><span class="line">       &#123;other_id,</span><br><span class="line">        &#123;event_manager_mod, start_link, []&#125;,</span><br><span class="line">        transient,</span><br><span class="line">        infinity,</span><br><span class="line">        worker,</span><br><span class="line">        dynamic&#125;]&#125;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>重启策略 <code>RestartStrategy</code> 的值可以为：</p>
<ul>
<li><code>one_for_one</code> ，当被监督的进程都是独立的、互不相关的，或者即便这些进程重启后丢失了自己的状态，也不会对其他进程产生影响时，可以使用 <code>one_for_one</code> 策略</li>
<li><code>one_for_all</code> ，当所有工作者进程都受同一个监督者监督，且这些工作者进程必须互相依赖才能正常工作时，就使用这个策略</li>
<li><code>rest_for_one</code> ，如果一个进程死了，那么所有在这个进程之后启动的进程（依赖于该进程）都将被重启，反之不然</li>
<li><code>simple_one_for_one</code> ，这个类型的监督者只监督一种子进程，当希望以动态的方式向监督者中增加子进程（当需要一个新的子进程时，向它发起请求，就能得到一个），而不是静态启动子进程时，可以使用这种策略</li>
</ul>
</li>
<li><p><code>RestartStrategy</code> 元组中剩余的两个变量是 <code>MaxRestart</code> 和 <code>MaxTime</code> 。他们的意思是，如果在 <code>MaxTime</code> （以秒为单位）指定的时间内，重启次数超过了 <code>MaxRestart</code> 指定的数字，那么监督者会放弃重启并终止所有子进程，然后自杀，永远停止运行</p>
</li>
<li><p>子进程规格说明可以描述成： <code>&#123;ChildId, StartFunc, Restart, Shutdown, Type, Modules&#125;</code></p>
</li>
<li><p><code>ChildId</code> 只是监督者内部使用的一个名称</p>
</li>
<li><p><code>StartFunc</code> 是一个元组，用来指定子进程的启动方式，它采用了标准的 <code>&#123;M, F, A&#125;</code> 格式。注意！这里的启动函数是OTP兼容的，在执行时会和调用者进程链接在一起，这一点非常重要</p>
</li>
<li><p><code>Restart</code> 指定了监督者在某个特定的子进程死后的处理方式，它可以取如下3个值：</p>
</li>
<li><p><code>permanent</code> : 不管发生什么，一个永久进程都要被重启</p>
</li>
<li><p><code>temporary</code> : 指的是那种绝对不应该被重启的进程</p>
</li>
<li><p><code>transient</code> : 介于上述两种进程之间。如果被正常终止了，就不会被重启。如果异常死亡，就会被重启</p>
</li>
<li><p><code>Shutdown</code> 当要求最顶层的监督者终止时，它会对每个子进程调用 <code>exit(ChildPid, shutdown)</code> 。如果这个子进程是一个工作者进程并且捕获了退出信号，那么就会调用自己的 <code>terminate</code> 函数；否则，进程死掉就行了。如果是一个监督者子进程收到了 <code>shutdown</code> 信号，它会用同样的方式将这个信号转发给它的子进程</p>
</li>
<li><p>子进程规格说明中的 <code>Shutdown</code> 值用来指定终止的超时期限，它可以设置一个确定的终止超时，可以是多少毫秒，也可以是 <code>infinity</code> 。如果指定时间过去了，进程还没有死，那么进程会被 <code>exit(Pid, kill)</code> 强行杀死</p>
</li>
<li><p>如果对子进程并不在意，不设定超时等待时间时，子进程死亡也没啥影响，那么可以将 <code>Shutdown</code> 设置成原子 <code>brutal_kill</code> 。使用 <code>brutal_kill</code> 会调用 <code>exit(Pid, kill)</code> 杀死子进程，此时，退出是即时的，子进程也无法捕获这个退出信号</p>
</li>
<li><p><code>Type</code> 字段可以让监督者知道子进程是一个监督者(supervisor)(实现了 <code>supervisor</code> 或者 <code>supervisor_bridge</code> 行为)还是一个工作者(worker)(任何其他OTP进程)</p>
</li>
<li><p><code>Modules</code> 是一个列表，其中只有一个元素：子进程行为使用的回调模块名。有一个例外情况：事先无法知道回调模块的标示符（如事件管理器中的事件处理器模块）。此时， <code>Modules</code> 的值要设置成 <code>dynamic</code> ，这样，在使用其他高级特性（如发布）时，整个OTP系统才能知道去找谁</p>
</li>
<li><p>动态监督使用 <code>one_for_one</code> 、 <code>rest_for_one</code> 或者 <code>one_for_all</code> 策略把工作者进程加入监督者中时，除了该进程的 <code>pid</code> 和其他一些信息外，还会向监督者持有的一个列表中增加子进程规格说明。在以后重启子进程或者执行其他任务时，会使用这份子进程规格说明。基于这种工作方式，相应的接口定义如下：</p>
<ul>
<li><code>start_child(SupervisorNameOrPid, ChildSpec)</code>  向列表中增加一个子进程规格说明，并且用该规格说明启动一个子进程</li>
<li><code>terminate_child(SupervisorNameOrPid, ChildId)</code>  终止或者强行杀死( <code>brutal_kills</code> )指定的子进程。子进程的规格说明仍然保留在监督者中</li>
<li><code>restart_child(SupervisorNameOrPid, ChildId)</code>  使用子进程规格说明重启子进程</li>
<li><code>delete_child(SupervisorNameOrPid, ChildId</code>  删除指定 <code>ChildId</code> 所对应的子进程规格说明</li>
<li><code>check_childspecs([ChildSpec])</code>  检查一个子进程规格说明是否有效。在调用 <code>start_child/2</code> 函数前，可以用这个函数去测试一下规格说明的有效性</li>
<li><code>count_children(SupervisorNameOrPid)</code>  分类列举出该监督者下的所有子进程，包括活动进程个数、子进程规格说明个数、监督者类型的个数和工作者类型的个数</li>
<li><code>which_children(SupervisorNameorPid)</code>  返回一个指定监督者下所有子进程信息的列表</li>
</ul>
</li>
<li><p>当子进程不多时，这些函数很适用于各种动态性要求（启动、终止等）。不过，由于内部使用的是列表，因此当需要快速访问大量子进程时，并不是很适用。此时所需要的是 <code>simple_one_for_one</code></p>
</li>
<li><p>使用 <code>simple_one_for_one</code> 策略的监督者把所有子进程信息存放在一个字典中，这样可以快速查找，并且对监督者的所有子进程来说，只有一份子进程规格说明</p>
</li>
<li><p>编写 <code>simple_one_for_one</code> 策略监督者的方式基本上和其他策略的监督者类似，只有一点不同： <code>&#123;M, F, A&#125;</code> 元组中的参数列表 <code>A</code> 并不是全部参数，完整的参数是把 <code>supervisor:start_child(Sup, Args)</code> 调用中的 <code>Args</code> 追加到 <code>A</code> 之后的新列表</p>
</li>
<li><p>这里的 <code>supervisor:start_child/2</code> 的含义改变了。与原来的 <code>supervisor:start_child(Sup, Spec)</code> 调用 <code>erlang:apply(M, F, A)</code> 不同，现在的 <code>supervisor:start_child(Sup, Args)</code> 调用的是 <code>erlang:apply(M, F, A++Args)</code></p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">init</span><span class="params">(jamband)</span> -&gt;</span></span><br><span class="line">    &#123;ok, &#123;&#123;simple_one_for_one, <span class="number">3</span>, <span class="number">60</span>&#125;,</span><br><span class="line">          [&#123;jam_musician,</span><br><span class="line">           &#123;musicians, start_link, []&#125;,</span><br><span class="line">           temporary, <span class="number">1000</span>, worker, [musicians]&#125;</span><br><span class="line">          ]&#125;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>仅当明确知道要监督的子进程数量不多并且（或者）不需要频繁地操控子进程，或者对性能要求不高的情况下，可以动态地使用标准监督者。对于其他需要动态监督的情况，尽可能使用 <code>simple_one_for_one</code></p>
</li>
</ul>

  </article>
  <!-- tag -->
  <div class="mt-12 pt-6 border-t border-gray-200">
    
      
        <span class="bg-gray-100 dark:bg-gray-700 px-2 py-1 m-1 text-sm rounded-md transition-colors hover:bg-gray-200">
          <a href="/tags/%E7%BC%96%E7%A8%8B/">编程</a>
        </span>
      
        <span class="bg-gray-100 dark:bg-gray-700 px-2 py-1 m-1 text-sm rounded-md transition-colors hover:bg-gray-200">
          <a href="/tags/Erlang/">Erlang</a>
        </span>
      
    
  </div>
  <!-- prev and next -->
  <div class="flex justify-between mt-12 pt-6 border-t border-gray-200">
    <div>
      
        <a href="/centos-install-postgresql-timescaledb.html" class="text-sm text-gray-400 hover:text-gray-500 flex justify-center">
          <iconify-icon width="20" icon="ri:arrow-left-s-line" data-inline="false"></iconify-icon>
          CentOS7安装PostgreSQL和TimeScaleDB
        </a>
      
    </div>
    <div>
      
        <a href="/docker-note.html" class="text-sm text-gray-400 hover:text-gray-500 flex justify-center">
          Docker学习笔记
          <iconify-icon width="20" icon="ri:arrow-right-s-line" data-inline="false"></iconify-icon>
        </a>
      
    </div>
  </div>
  <!-- sponsors -->
  <div class="mt-12">
    <p class="text-center text-sm text-gray-400">如果这篇文章对您有帮助的话，那就请我喝杯咖啡吧！</p>

    <div class="mt-5 flex justify-center">
        <img src="/images/sponsors/alipay.png" width = "200" height="300" alt="Alipay" />
        <div>&nbsp;&nbsp;</div>
        <img src="/images/sponsors/weixin.jpeg" width = "200" height="300" alt="WeiXin" />
    </div>
  </div>
  <!-- comment -->
  <div class="article-comments mt-12">
    
<script src="https://giscus.app/client.js"
        data-repo="shixiongfei/shixiongfei.github.io"
        data-repo-id="MDEwOlJlcG9zaXRvcnkzMzMzMzg5ODc="
        data-category="General"
        data-category-id="DIC_kwDOE95Za84CVZLb"
        data-mapping="pathname"
        data-strict="0"
        data-reactions-enabled="1"
        data-emit-metadata="0"
        data-input-position="bottom"
        data-theme="preferred_color_scheme"
        data-lang="zh-CN"
        crossorigin="anonymous"
        async>
</script>


  </div>
</section>

  </main>
  <footer class="flex flex-col h-40 items-center justify-center text-gray-400 text-sm">
  <!-- busuanzi -->
  

  <!-- copyright -->
  <div class="flex items-center gap-2">
    <span>© 2018-2023</span>
    <iconify-icon width="18" icon="emojione-monotone:maple-leaf" ></iconify-icon>
    <a href="https://shixiongfei.com" target="_blank" rel="noopener noreferrer">shixiongfei</a>
  </div>
  <!-- powered by -->
  <div class="flex items-center gap-2">
    <span>Powered by</span>
    <a href="https://hexo.io/" target="_blank" rel="noopener noreferrer">Hexo</a>
    <span>&</span>
    <a href="https://github.com/xbmlz/hexo-theme-maple" target="_blank" rel="noopener noreferrer">Maple</a>
  </div>

</footer>

  <iconify-icon class="fixed right-4 bottom-10 z-100 opacity-0" width="24" icon="ion:arrow-up-c" id="go-top"></iconify-icon>
  
<script src="/lib/clipboard.min.js"></script>



<script src="/js/main.js"></script>



<script async src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    "HTML-CSS": {
        preferredFont: "TeX",
        availableFonts: ["STIX","TeX"],
        linebreaks: { automatic:true },
        EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
    },
    tex2jax: {
        inlineMath: [ ["$", "$"], ["\\(","\\)"] ],
        processEscapes: true,
        ignoreClass: "tex2jax_ignore|dno",
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
        equationNumbers: { autoNumber: "AMS" },
        noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
        Macros: { href: "{}" }
    },
    messageStyle: "none"
  });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>



<script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
<script>
  $(document).ready(() => {
    const maraidConfig = {
      theme: "default",
      logLevel: 3,
      flowchart: { curve: "linear" },
      gantt: { axisFormat: "%m/%d/%Y" },
      sequence: { actorMargin: 50 },
    };
    mermaid.initialize(maraidConfig);
  });
</script>



<script src="/lib/fancybox/fancybox.umd.min.js"></script>

<script>
  $(document).ready(() => {
    $('.post-content').each(function(i){
      $(this).find('img').each(function(){
        if ($(this).parent().hasClass('fancybox') || $(this).parent().is('a')) return;
        var alt = this.alt;
        if (alt) $(this).after('<span class="fancybox-alt">' + alt + '</span>');
        $(this).wrap('<a class="fancybox-img" href="' + this.src + '" data-fancybox=\"gallery\" data-caption="' + alt + '"></a>')
      });
      $(this).find('.fancybox').each(function(){
        $(this).attr('rel', 'article' + i);
      });
    });

    Fancybox.bind('[data-fancybox="gallery"]', {
        // options
    })
  })
</script>

<!-- tocbot begin -->

<script src="/lib/tocbot/tocbot.min.js"></script>

<script>
  $(document).ready(() => {
      tocbot.init({
        // Where to render the table of contents.
        tocSelector: '.post-toc',
        // Where to grab the headings to build the table of contents.
        contentSelector: '.post-content',
        // Which headings to grab inside of the contentSelector element.
        headingSelector: 'h1, h2, h3',
        // For headings inside relative or absolute positioned containers within content.
        hasInnerContainers: true,
    });
  })
</script>
<!-- tocbot end -->


</body>

</html>
